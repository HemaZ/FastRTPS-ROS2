// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file ImagePublisher.cpp
 * This file contains the implementation of the publisher functions.
 *
 * This file was generated by the tool fastcdrgen.
 */

#include <fastrtps/participant/Participant.h>
#include <fastrtps/attributes/ParticipantAttributes.h>
#include <fastrtps/publisher/Publisher.h>
#include <fastrtps/attributes/PublisherAttributes.h>

#include <fastrtps/Domain.h>
#include <vector>
#include <thread>
#include <chrono>

#include <opencv2/core.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>

#include "ImagePublisher.h"

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;
using namespace cv;

void toImageMsg(sensor_msgs::msg::Image & ros_image, cv::Mat &image);
ImagePublisher::ImagePublisher() : mp_participant(nullptr), mp_publisher(nullptr) {}

ImagePublisher::~ImagePublisher() {	Domain::removeParticipant(mp_participant);}

bool ImagePublisher::init()
{
    // Create RTPSParticipant

    ParticipantAttributes PParam;
    PParam.rtps.setName("Participant_publisher");  //You can put here the name you want
    mp_participant = Domain::createParticipant(PParam);
    if(mp_participant == nullptr)
    {
        return false;
    }

    //Register the type

    Domain::registerType(mp_participant, static_cast<TopicDataType*>(&myType));

    // Create Publisher

    PublisherAttributes Wparam;
    Wparam.topic.topicKind = NO_KEY;
    Wparam.topic.topicDataType = myType.getName();  //This type MUST be registered
    Wparam.topic.topicName = "rt/ImagePubSubTopic";

    mp_publisher = Domain::createPublisher(mp_participant,Wparam,static_cast<PublisherListener*>(&m_listener));

    if(mp_publisher == nullptr)
    {
        return false;
    }

    std::cout << "Publisher created, waiting for Subscribers." << std::endl;
    return true;
}

void ImagePublisher::PubListener::onPublicationMatched(Publisher* pub,MatchingInfo& info)
{
    (void)pub;

    if (info.status == MATCHED_MATCHING)
    {
        n_matched++;
        std::cout << "Publisher matched" << std::endl;
    }
    else
    {
        n_matched--;
        std::cout << "Publisher unmatched" << std::endl;
    }
}

void ImagePublisher::run()
{
    // while(m_listener.n_matched == 0)
    // {
    //     std::this_thread::sleep_for(std::chrono::milliseconds(250)); // Sleep 250 ms
    // }

    // Publication code

    sensor_msgs::msg::Image st;

    /* Initialize your structure here */
    Mat frame;
    VideoCapture cap;
    int deviceID = 0;             // 0 = open default camera
    int apiID = cv::CAP_ANY;      // 0 = autodetect default API
    // open selected camera using selected API
    cap.open(deviceID + apiID);
    // check if we succeeded
    if (!cap.isOpened()) {
        std::cout << "ERROR! Unable to open camera\n";
    }
    
    int msgsent = 0;
    for (;;)
    {
        // wait for a new frame from camera and store it into 'frame'
        cap.read(frame);
        // check if we succeeded
        if (frame.empty()) {
            std::cout << "ERROR! blank frame grabbed\n";
            break;
        }
        // show live and wait for a key with timeout long enough to show images
        // imshow("Live", frame);
        toImageMsg(st, frame);
        mp_publisher->write(&st);  ++msgsent;
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        if (waitKey(5) >= 0)
            break;
    }
    
}
void toImageMsg(sensor_msgs::msg::Image & ros_image, cv::Mat &image) 
{
  ros_image.height(image.rows);
  std::cout << ros_image.data().size()<<std::endl;
  ros_image.width(image.cols);
  ros_image.encoding("bgr8");
  ros_image.step(image.cols * image.elemSize());
//   size_t size = ros_image.step() * image.rows;
//   ros_image.data().resize(size);
//   std::cout << "DATA SIZE " << ros_image.data().size() << std::endl; 
//   memcpy(&ros_image.data()[0], image.data, size);
    std::vector<uint8_t> data = {0};
  for (size_t i = 0; i < 307200; i++)
  {
     data.push_back(0);
  }
  
//   ros_image.data(data);
//   ros_image.data(data);
//   std::cout << ros_image.data().size()<<std::endl;
//   ros_image.data(data);
//   ros_image.data().resize(size);

//   if (image.isContinuous()) {
//     memcpy(reinterpret_cast<char *>(&ros_image.data()[0]), image.data, size);
//   } else {
//     // Copy by row by row
//     uchar * ros_data_ptr = reinterpret_cast<uchar *>(&ros_image.data()[0]);
//     uchar * cv_data_ptr = image.data;
//     for (int i = 0; i < image.rows; ++i) {
//       memcpy(ros_data_ptr, cv_data_ptr, ros_image.step());
//       ros_data_ptr += ros_image.step();
//       cv_data_ptr += image.step;
//     }
//   }
}